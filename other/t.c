#include "library.h"

//uint8_t — это тип данных, определенный в заголовочном файле <stdint.h>, который представляет 
//собой 8-битное (1-байтовое) беззнаковое целое число. Он гарантирует, что размер переменной будет 
//ровно 8 бит вне зависимости от платформы
typedef struct Allocator {
    void *memory; //область памяти, которую будет использовать аллокатор
    size_t size; //общий размер доступной памяти (за вычетом размера структуры Allocator)
    uint8_t *bitmap; //указатель на битовую карту, которая отслеживает занятость блоков памяти
    size_t block_size; //размер каждого блока памяти, который будет выделяться
} Allocator;
//Каждый бит в битовой карте соответствует блоку памяти:
//    0 означает, что блок свободен.
//    1 означает, что блок занят.


//создает аллокатор, принимая указатель на область памяти и ее размер
//const используется для указания, что указатель memory не будет изменен внутри функции.
Allocator* allocator_create(void *const memory, const size_t size) {
    if (!memory || size == 0) return NULL;

    Allocator *allocator = (Allocator *)memory;
    allocator->memory = (void *)((uint8_t *)memory + sizeof(Allocator));
    allocator->size = size - sizeof(Allocator);
    allocator->block_size = 32; //Память будет разделена на блоки по 32 байт изначально
    //Устанавливает указатель bitmap на начало области памяти, выделенной для битовой карты
    allocator->bitmap = (uint8_t *)allocator->memory;

    size_t bitmap_size = allocator->size / allocator->block_size / 8;
    //Обнуляет битовую карту, устанавливая все биты в 0, что означает, что все блоки памяти свободны
    memset(allocator->bitmap, 0, bitmap_size);
    //Обновляет указатель memory, устанавливая его на адрес, следующий за битовой картой, чтобы указать 
    //на область, где будут размещаться выделенные блоки памяти
    allocator->memory = (uint8_t *)allocator->bitmap + bitmap_size;

    return allocator;
}

void allocator_destroy(Allocator *const allocator) {
    if (allocator) {
        memset(allocator, 0, allocator->size);
    }
}

void* allocator_alloc(Allocator *const allocator, const size_t size) {
    if (!allocator || size == 0 || size > allocator->size) return NULL;

    //Эта формула используется для определения, сколько блоков памяти нужно выделить для запрашиваемого размера size
    size_t blocks_needed = (size + allocator->block_size - 1) / allocator->block_size; 
    //количество блоков, доступных в аллокаторе
    size_t total_blocks = allocator->size / allocator->block_size;
    uint8_t *bitmap = allocator->bitmap;

    size_t free_blocks = 0;
    //цикл по всем блокам в памяти
    for (size_t i = 0; i < total_blocks; ++i) {
        //Проверяет, свободен ли текущий блок, используя битовую карту
        //i / 8 — это индекс байта в битовой карте, который соответствует блоку i.
        //i % 8 — это позиция бита внутри этого байта (от 0 до 7).
        //1 << (i % 8) создает битовую маску, где установлен только один бит, соответствующий позиции i % 8.
        //Оператор & проверяет, установлен ли этот бит. Если бит равен 0, это означает, что блок свободен.
        if (!(bitmap[i / 8] & (1 << (i % 8)))) {
            ++free_blocks;
            //Проверяет, достаточно ли свободных блоков для удовлетворения запроса
            if (free_blocks == blocks_needed) {
                //Вычисляет индекс первого блока, который будет выделен
                size_t start_block = i - blocks_needed + 1;

                //Начинает цикл для установки битов в битовой карте, чтобы пометить выделенные блоки как занятые
                for (size_t j = start_block; j <= i; ++j) {
                    //Устанавливает бит в битовой карте, помечая блок как занятый
                    //j / 8 — это индекс байта в битовой карте.
                    //j % 8 — это позиция бита внутри этого байта.
                    //1 << (j % 8) создает битовую маску, где установлен только один бит, соответствующий позиции j%8
                    //Оператор |= устанавливает этот бит в 1, тем самым помечая блок как занятый.
                    bitmap[j / 8] |= (1 << (j % 8));
                }

                //Возвращает указатель на выделенный блок памяти, вычисляя его адрес на основе start_block
                return (uint8_t *)allocator->memory + start_block * allocator->block_size;
            }
        } else {
            free_blocks = 0;
        }
    }

    return NULL;
}

void allocator_free(Allocator *const allocator, void *const memory) {
    if (!allocator || !memory) return;

    //Вычисляет смещение выделенной памяти относительно начала области, управляемой аллокатором
    //Смещение необходимо для того, чтобы определить, какой блок памяти мы собираемся освободить. 
    //Указатель memory указывает на адрес выделенной памяти, а allocator->memory указывает на начало области, 
    //управляемой аллокатором. Вычитая одно из другого, мы получаем смещение, которое показывает, насколько 
    //далеко находится данный блок от начала управляемой области.
    size_t offset = (uint8_t *)memory - (uint8_t *)allocator->memory;

    //Проверяет, что адрес освобождаемой памяти выровнен по размеру блока
    //Если смещение не делится нацело на размер блока, это означает, что указатель memory не указывает 
    //на начало блока, и освобождение памяти не будет корректным. 
    if (offset % allocator->block_size != 0) return;

    //Индекс блока в битовой карте нужен для того, чтобы определить, какой именно бит в битовой карте 
    //нужно изменить, помечая блок как свободный. 
    size_t block_index = offset / allocator->block_size;

    //Устанавливает соответствующий бит в битовой карте в 0, помечая блок как свободный
    //block_index / 8 — это индекс байта в битовой карте, который соответствует блоку block_index.
    //block_index % 8 — это позиция бита внутри этого байта.
    //1 << (block_index % 8) создает битовую маску, где установлен только один бит, соответствующий позиции 
        //block_index % 8.
    //Оператор ~ инвертирует биты в маске, устанавливая все биты в 1, кроме целевого бита, который будет равен 0.
    //Оператор &= используется для установки этого бита в 0, тем самым помечая блок как свободный.
    allocator->bitmap[block_index / 8] &= ~(1 << (block_index % 8));
}