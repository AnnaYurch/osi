gcc -o parent parent.c -lpthread //-pthread -lrt
gcc -o child child.c -lpthread
./parent

gcc -o parent parent.c -lrt -lpthread
gcc -o child child.c -lrt -lpthread


-----------------------------------------------------------------------------------------

Семафор - Семафор представляет разделяемую целочисленную переменную, которая применяется 
для ограничения количества потоков, которые имеют доступ к некоторому коду или ресурсам. 
Семафоры позволяют ограничить доступ к участку кода только определенному количестиву потоков. 
Также с помощью семафоров можно заставить один поток ждать, пока другой не выполнит 
определенное действие, таким образом упорядочивая действия потоков.

-----------------------------------------------------------------------------------------

sem_t *sem_open(const char *name, int oflag);
sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);
sem_open - создаёт новый семафор POSIX или открывает существующий семафор.

Семафору присваивается имя name. 
В аргументе oflag задаются флаги, которые управляют работой вызова (определения значений 
флагов можно получить включив <fcntl.h>). 
Если в oflag указано O_CREAT, то семафор создаётся, если ещё не существует. 
Если в oflag указаны O_CREAT и O_EXCL одновременно и семафор с заданным name уже существует, 
то возвращается ошибка. 
Если в oflag указано O_CREAT, то должны быть заданы ещё два аргумента. 
В аргументе mode задаются права для нового семафора, подобно open(2) 
(символические определения бит прав можно получить включив <sys/stat.h>). 
Настройки прав маскируются маской процесса. Права чтения и записи должны быть заданы для 
каждого класса пользователей, которым нужен доступ к семафору. 
В аргументе value задаётся начальное значение нового семафора. 
Если указан O_CREAT и семафор с заданным name существует, то mode и value игнорируются. 
Не устанавливайте oflags в O_RDONLY, O_RDWR или O_WRONLY. Поведение семафора с ними не определено. 

При успешном выполнении sem_open() возвращает адрес нового семафора; этот адрес 
используется при вызове других функций, работающих с семафорами. 
При ошибке sem_open() возвращает SEM_FAILED, а в errno записывается номер ошибки. 

-----------------------------------------------------------------------------------------

int ftruncate(int fd, off_t length);  
ftruncate - Функция ftruncate устанавливают длину обычного файла с файловым дескриптором fd в length байт. 
Если файл до этой операции был длиннее, то отсеченные данные теряются. 
Если файл был короче, то он увеличивается, а добавленная часть заполняется нулевыми байтами.
Указатель на файл не меняется.
При использовании ftruncate файл должен быть открыт для записи;

При успешной работе функции возвращаемое значение равно нулю. При ошибке возвращается -1, 
а переменной errno присваивается номер ошибки.  

-----------------------------------------------------------------------------------------

void * mmap(void *start, size_t length, int prot , int flags, int fd, off_t offset); 
mmap - Функция mmap отражает length байтов, начиная со смещения offset файла, 
определенного файловым описателем fd, в память, начиная с адреса start. 
Последний параметр (адрес) необязателен, и обычно бывает равен 0. Настоящее местоположение 
отраженных данных возвращается самой функцией mmap, и никогда не бывает равным 0.
Аргумент prot описывает желаемый режим защиты памяти (он не должен конфликтовать с режимом открытия файла). 
Оно является либо PROT_NONE либо побитовым ИЛИ одного или нескольких флагов PROT_*. 


При удачном выполнении mmap возвращает указатель на область с отраженными данными. При ошибке 
возвращается значение MAP_FAILED (-1), а переменная errno приобретает соответствующее значение. 

-----------------------------------------------------------------------------------------

int shm_open(const char *name, int oflag, mode_t mode); 
shm_open - создает и открывает новый (или открывает уже существующий) объект разделяемой памяти POSIX. 
Объект разделяемой памяти POSIX - это обработчик, используемый несвязанными процессами для исполнения 
mmap(2) на одну область разделяемой памяти. 
Это позволяет процессу взаимодействовать с файлом как с массивом в памяти, что может быть полезно 
для работы с большими файлами или для совместного использования данных между процессами.

Операция shm_open аналогична open(2). name определяет собственно создаваемый объект разделяемой памяти 
для создания или открытия. Для использования в портируемых программах name должно иметь в начале 
косую черту (/) и больше не содержать их внутри имени.

oflag является маской битов, созданной через логическое сложение OR одного из флагов O_RDONLY или O_RWDR 
и любых других флагов, перечисленных далее:
O_RDWR
    Открывает объект для чтения и записи. 
O_CREAT
    Создает объект разделяемой памяти, если он еще не существует. Владелец и группа объекта устанавливаются 
    как для open(2), а биты прав объекта устанавливаются в соответствии с 9 битами mode младшего порядка, 
    за исключением того, что эти биты, установленные во время обработки маски создания режимов файла 
    (см. umask(2)) очищаются у новых объектов. (Набор макро-констант, используемых для определения 
    режима mode перечислен в open(2).)

    Новый объект разделяемой памяти изначально имеет нулевую длину, размер объекта можно установить, 
    используя ftruncate(2). (Новые, только что распределенные байты объекта разделяемой памяти автоматически 
    инициализируются в 0.) 

 При нормальном завершении работы shm_open возвращает неотрицательный дескриптор файла
 При ошибках shm_open возвращает -1.
    
-----------------------------------------------------------------------------------------

fork - создает новый дочерний процесс, для запуска child

-----------------------------------------------------------------------------------------

int sem_wait(sem_t *sem);
sem_wait - Функция уменьшает (блокирует) семафор, на который указывает sem. Если значение семафор больше нуля, 
то выполняется уменьшение и функция сразу завершается. Если значение семафора равно нулю, то вызов блокируется 
до тех пор, пока не станет возможным выполнить уменьшение (т. е., значение семафора не станет больше нуля), 
или пока не вызовется обработчик сигнала. 

При успешном выполнении все функции возвращают 0; 
при ошибке значение семафора не изменяется, возвращается -1, а в errno указывается причина ошибки. 

-----------------------------------------------------------------------------------------

int sem_post(sem_t *sem);
sem_post - Функция увеличивает (разблокирует) семафор, на который указывает sem. Если значение семафора 
после этого становится больше нуля, то другой процесс или нить заблокированная в вызове sem_wait(3), 
проснётся и заблокирует семафор. 


При успешном выполнении sem_post() возвращается 0; 
при ошибке значение семафора остаётся неизменным, возвращается -1, а в errno содержится код ошибки. 

-----------------------------------------------------------------------------------------

int munmap(void *start, size_t length); 
munmap - Системный вызов munmap удаляет все отражения из заданной области памяти, после чего все ссылки 
на данную область будут вызывать ошибку "неправильное обращение к памяти" (invalid memory reference). 
Отражение удаляется автоматически при завершении процесса. С другой стороны, закрытие файла не приведет 
к снятию отражения. 

При удачном выполнении munmap возвращаемое значение равно нулю. 
При ошибке возвращается -1, а переменная errno приобретает соответствующее значение. 

-----------------------------------------------------------------------------------------

int shm_unlink(const char *name); 
shm_unlink - Функция выполняет обратную операцию, удаляя объект, созданный ранее с помощью shm_open(). 
Значением name определяется удаляемый объект общей памяти. 

При успешном выполнении shm_unlink() возвращает 0 и -1 при ошибке. 

-----------------------------------------------------------------------------------------

int sem_close(sem_t *sem);
sem_close - Функция закрывает именованный семафор, на который указывает sem, позволяя 
освободить все ресурсы, которые система выделила под семафор вызывающему процессу. 

При успешном выполнении sem_close() возвращается 0; 
при ошибке возвращается -1, а в errno содержится код ошибки. 

-----------------------------------------------------------------------------------------

int sem_unlink(const char *name);
sem_unlink - Функция удаляет именованный семафор, на который ссылается name. Имя семафора 
удаляется немедленно. Семафор уничтожается после того, как все остальные процессы, в которых он открыт, 
закроют его. 

При успешном выполнении возвращается 0; 
при ошибке возвращается -1, а в errno содержится код ошибки. 

-----------------------------------------------------------------------------------------

waitpid - чтоб родительский процесс не завершился до завершения дочернего

-----------------------------------------------------------------------------------------

int execl(char *name, char *arg0, ... /*NULL*/);
execl - Функция (execute) загружает и запускает другую программу. 
        l (список). Аргументы командной строки передаются в форме списка arg0, arg1.... argn, NULL. 
        Эту форму используют, если количество аргументов известно; 

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
parent.c





#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <semaphore.h>
#include <sys/types.h>
#include <sys/wait.h>

#define SHM_NAME "/my_shm"
#define SEM_WRITE_NAME "/sem_write"
#define SEM_READ_NAME "/sem_read"

int main() {
    char filename[256];
    write(STDOUT_FILENO, "Enter the filename to store composite numbers: ", 47);
    int len = read(STDIN_FILENO, filename, sizeof(filename));
    if (len <= 1) {
        const char msg[] = "error: invalid filename\n";
        write(STDERR_FILENO, msg, sizeof(msg));
        exit(EXIT_FAILURE);
    }

    filename[len - 1] = '\0';

    int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
    //Создание общей памяти с именем, определенным ранее. 
    //O_CREAT создает объект, если он не существует, а O_RDWR открывает его для чтения и записи.
    //число 0666 представляет собой режим доступа (права доступа) для создаваемого объекта общей памяти. 
    //Таким образом, 0666 позволяет всем пользователям (владельцу, группе и остальным) читать и записывать 
    //в общую память, но не позволяет выполнять (execute).
    //execute - позволяет пользователю запускать файл как программу.
    //!!!Но процесс не может напрямую обращаться к этому объекту, пока он не будет отображен 
    //в его адресном пространстве.
    
    ftruncate(shm_fd, sizeof(int) * 256);
    //Установка размера общей памяти на 1024 байт

    int *shared_memory = mmap(0, sizeof(int) * 256, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    //Отображение общей памяти в адресное пространство процесса. mmap возвращает указатель на начало общей памяти.
    //Это позволяет процессу взаимодействовать с файлом как с массивом в памяти, что может быть полезно 
    //для работы с большими файлами или для совместного использования данных между процессами.
    //процесс может как читать, так и записывать данные в эту область памяти.
    //Четвёртый аргумент указывает, что отображаемая память будет разделяемой. Это позволяет другим процессам, 
    //которые также отображают ту же область памяти, видеть изменения, внесённые в эту область. 

    sem_t *sem_write = sem_open(SEM_WRITE_NAME, O_CREAT, 0666, 1);
    //Создание семафора для управления записью в общую память. Изначально он устанавливается в 1 (разрешает запись)
    //O_CREAT - семафор создаётся, если ещё не существует.
    //Семафору присваивается имя name.
    
    sem_t *sem_read = sem_open(SEM_READ_NAME, O_CREAT, 0666, 0);
    //Создание семафора для управления чтением из общей памяти. Изначально он устанавливается в 0 (запрещает чтение)
    //Когда дочерний процесс хочет прочитать данные из общей памяти, он должен сначала дождаться, 
    //пока родительский процесс запишет данные и вызовет sem_post(sem_read). Это увеличивает 
    //семафора, сигнализируя дочернему процессу, что данные готовы для чтения.

    pid_t pid = fork();
    //Создает новый процесс. 
    //Возвращает 0 в дочернем процессе и идентификатор процесса (PID) дочернего процесса в родительском.
    
    if (pid == -1) {
        const char msg[] = "error: fork failed\n";
        write(STDERR_FILENO, msg, sizeof(msg));
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // Дочерний процесс
        execl("./child", "./child", filename, NULL);
        //"./child" - Это путь к исполняемому файлу, который будет запущен. 
        //"./child" - Это имя программы, которое будет использоваться в переменной argv[0] внутри нового процесса. 
        //filename - Это аргумент, который передается в новый процесс. 
        //NULL - Это завершающий аргумент, который указывает конец списка аргументов.
        
        //Запускает исполняемый файл child, передавая ему имя файла. 
        //Если execl успешен, текущий процесс заменяется на новый.
        //Если execl не удался, дочерний процесс завершается с кодом ошибки.

        _exit(1);
    } else {
        // Родительский процесс
        int number;
        while (1) {
            write(STDOUT_FILENO, "Enter a number (negative to exit): ", 35);
            char buffer[256];
            int len = read(STDIN_FILENO, buffer, sizeof(buffer));
            if (len <= 1) break;

            buffer[len - 1] = '\0';
            number = atoi(buffer);

            if (number < 0) {
                sem_wait(sem_write);
                shared_memory[0] = number;  // Отправляем сигнал завершения
                sem_post(sem_read);
                break;
            }

            sem_wait(sem_write);
            shared_memory[0] = number;  // Записываем число в общую память
            sem_post(sem_read);
        }

        // Ожидание завершения дочернего процесса
        wait(NULL);

        // Освобождение ресурсов
        munmap(shared_memory, sizeof(int) * 256); //Освобождает отображение общей памяти.
        shm_unlink(SHM_NAME); //Удаляет объект общей памяти.
        sem_close(sem_write); //Закрывает семафор записи.
        sem_close(sem_read); //Закрывает семафор чтения.
        sem_unlink(SEM_WRITE_NAME); //Удаляет семафор записи.
        sem_unlink(SEM_READ_NAME); //Удаляет семафор чтения.

        
        write(STDOUT_FILENO, "Parent process exiting.\n", 24);
    }

    return 0;
}





/////////////////////////////////////////////////////////////////////
child.c 





#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <stdbool.h>
#include <semaphore.h>

#define SHM_NAME "/my_shm" //Определяет имя объекта общей памяти.
#define SEM_WRITE_NAME "/sem_write" //Определяет имя семафора для управления записью в общую память.
#define SEM_READ_NAME "/sem_read" //Определяет имя семафора для управления чтением из общей памяти.

bool is_prime(int num) {
    if (num <= 1) return false;
    for (int i = 2; i * i <= num; i++) {
        if (num % i == 0) return false;
    }
    return true;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        const char msg[] = "error: not enough arg\n";
        write(STDERR_FILENO, msg, sizeof(msg));
        exit(EXIT_FAILURE);
    }

    const char *filename = argv[1];

    // Открытие общей памяти
    int shm_fd = shm_open(SHM_NAME, O_RDONLY, 0666);
    //SHM_NAME - Это строка, представляющая имя объекта общей памяти.
    //O_RDONLY - Это флаг, который указывает, что объект общей памяти будет открыт только для чтения. 
    //Этот аргумент задает права доступа для нового объекта общей памяти, если он создается. 
    //В данном случае, права 0666 означают, что все пользователи (владелец, группа и другие) имеют 
    //право на чтение и запись в объект. Однако, так как вы используете O_RDONLY, эти права не будут 
    //иметь значения, если вы только читаете из объекта.

    int *shared_memory = mmap(0, sizeof(int) * 256, PROT_READ, MAP_SHARED, shm_fd, 0);
    //Отображает общую память в адресное пространство процесса. Возвращает указатель на начало общей памяти. 
    //PROT_READ указывает, что память будет доступна только для чтения, а MAP_SHARED позволяет другим 
    //процессам видеть изменения.

    // Открытие семафоров
    sem_t *sem_write = sem_open(SEM_WRITE_NAME, 0);
    sem_t *sem_read = sem_open(SEM_READ_NAME, 0);

    int file_fd = open(filename, O_WRONLY | O_CREAT | O_APPEND, 0644);  //O_WRONLY - открываем для записи,
    if (file_fd < 0) {                                                  //O_CREAT - создаем, если нет,
        const char msg[] = "error with open requested file\n";          //O_APPEND - добавляем в конец,
        write(STDERR_FILENO, msg, sizeof(msg));                    //0644 - права доступа на файл (r/w - владелец, r)
        exit(EXIT_FAILURE);
    }

    int number;
    while (1) {
        sem_wait(sem_read); 
        //Ожидает, пока семафор чтения будет доступен, чтобы безопасно прочитать данные из общей памяти.
        number = shared_memory[0]; //Читает число из общей памяти.

        if (number < 0) {
            write(STDOUT_FILENO, "Child indicated to terminate\n", 29);
            break;
        }

        if (!(is_prime(number) || number == 1 || number == 0)) {
            char buffer[20];
            int len = snprintf(buffer, sizeof(buffer), "%d\n", number);
            write(file_fd, buffer, len);
        }

        sem_post(sem_write);
        //Освобождает семафор записи, сигнализируя родительскому процессу, что данные были обработаны.
    }

    close(file_fd); //Закрывает дескриптор файла.
    munmap(shared_memory, sizeof(int) * 256); //Освобождает отображение общей памяти.
    shm_unlink(SHM_NAME); //Удаляет объект общей памяти.
    sem_close(sem_write); //Закрывает семафор записи.
    sem_close(sem_read); //Закрывает семафор чтения.
    

    return 0;
}
