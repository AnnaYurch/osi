Да, malloc можно назвать аллокатором, так как она отвечает за динамическое выделение памяти в программе. 
Аллокатор — это компонент или функция, которая управляет выделением и освобождением памяти. 
В контексте языка C malloc (memory allocation) является одной из основных функций для этой задачи.

Она выделяет запрашиваемый объём памяти и возвращает указатель на него, что позволяет программе использовать 
эту память во время выполнения. Поэтому в более широком смысле malloc действительно выполняет функции аллокатора.

==============================================================================================================

алгоритм двойников

    все выделяемые блоки имеют размер в степень двойки, 4, 8, 16, 32, … байт;

    размер изначального единого свободного блока (при старте программы) тоже равен степени 2;

    свободные блоки одного размера объединены в двунаправленный список;

    когда требуется выделить блок размера S:

        находим минимальную степень 2 больше S;

        проверяем наличие свободных страниц такого размера, отдаём если есть;

        если нет, находим минимальный блок большего размера и рекурсивно расщепляем его до нужного размера. 
        Получившиеся “обрезки” пополняют списки свободных блоков. 

    при освобождении блока:

        находим размер блока;

        проверяем, свободен ли второй блок (buddy) и если свободен, объединяем их и рекурсивно проверяем 
        вышестоящий (уже объединённый) блок.

    размер и флаг занятости можно хранить в начале блока, как и в вышеописанном алгоритме, возможны и другие 
    варианты.

Размер соседнего блока (двойника, buddy) всегда равен размеру освобождаемого. 
Причем сосед только один (слева или справа, согласно алгоритму выделения), его адрес легко установить из значения указателя текущего блока и его размера.

Алгоритм двойников потребляет в среднем больше памяти (т.н. внутренняя фрагментация за счет округления 
размера до степени двойки), но мистическим образом не подвержен внешней фрагментации. 

==============================================================================================================

алгритм со списками (односвязный) свободных блоков (наиболее подходящее)

при создании вся память - это один большой свободный блок
размер блоков произвольный
ищем наиболее подходящий по размеру, и если он больше необходимого, то можно его разбить еще

при освобождении памяти свободные соседнии блоки "складываем"
если размер блока меньше минимального, выделяется минимально допустимый блок

==============================================================================================================
==============================================================================================================
==============================================================================================================

uint8_t: беззнаковое целое число размером 8 байт

==============================================================================================================

void *memset(void *buf, int ch, size_t count)
Функция memset() копирует младший байт ch в первые count символов массива, на который указывает buf. 
Функция возвращает buf.

Чаще всего memset() используется для присвоения начальных значений определенной области памяти.

==============================================================================================================

void * mmap(void *start, size_t length, int prot , int flags, int fd, off_t offset); 
mmap - Функция mmap отражает length байтов, начиная со смещения offset файла, 
определенного файловым описателем fd, в память, начиная с адреса start. 
Последний параметр (адрес) необязателен, и обычно бывает равен 0. Настоящее местоположение 
отраженных данных возвращается самой функцией mmap, и никогда не бывает равным 0.
Аргумент prot описывает желаемый режим защиты памяти (он не должен конфликтовать с режимом открытия файла). 
Оно является либо PROT_NONE либо побитовым ИЛИ одного или нескольких флагов PROT_*. 

mmap с флагом MAP_ANONYMOUS — это механизм в Unix-подобных операционных системах, который позволяет 
выделить анонимную область памяти, не связанную с каким-либо файлом. Эта память может быть использована 
для различных целей, таких как выделение больших блоков памяти, создание разделяемой памяти между процессами 
или реализация пользовательских аллокаторов

При удачном выполнении mmap возвращает указатель на область с отраженными данными. При ошибке 
возвращается значение MAP_FAILED (-1), а переменная errno приобретает соответствующее значение. 

==============================================================================================================

int munmap(void *start, size_t length); 
munmap - Системный вызов munmap удаляет все отражения из заданной области памяти, после чего все ссылки 
на данную область будут вызывать ошибку "неправильное обращение к памяти" (invalid memory reference). 
Отражение удаляется автоматически при завершении процесса. С другой стороны, закрытие файла не приведет 
к снятию отражения. 

При удачном выполнении munmap возвращаемое значение равно нулю. 
При ошибке возвращается -1, а переменная errno приобретает соответствующее значение. 

==============================================================================================================

void *dlopen(const char *filename, int flag); 
dlopen загружает динамическую библиотеку, имя которой указано в строке filename, и возвращает прямой указатель 
на начало динамической библиотеки. Если filename не является полным именем файла (т.е. не начинается с "/"), 
то файл ищется в следующих местах:
    * в разделенном двоеточием списке каталогов, в переменной окружения пользователя LD_LIBRARY_PATH.
    * В списке библиотек, кэшированных в файле /etc/ld.so.cache.
    * В /usr/lib и далее в /lib. 

Если filename указывает на NULL, то возвращается указатель на основную программу.
Внешние ссылки разрешаются при работе с библиотеками в списке библиотечных зависимостей и любыми другими, 
которые уже открыты с флагом RTLD_GLOBAL. Если исполняемый модуль был собран с флагом "-rdynamic", его 
символьная информация также используется для разрешения ссылок в динамически загружаемых библиотеках.

Значение flag должно быть одним из двух: RTLD_LAZY, подразумевающим разрешение неопределенных символов в виде 
кода, содержащегося в исполняемой динамической библиотеке; или RTLD_NOW, требующим разрешения всех неопределенных 
символов перед возвратом их из dlopen и возвращающим ошибку, если разрешение не может быть выполнено. 
Также значение RTLD_GLOBAL может быть задано через OR вместе с flag; в этом случае внешние символы, 
определенные в библиотеке, будут доступны загруженным позже библиотекам.

Если библиотека экспортировала функцию, названную _init, то ее код выполняется перед возвратом из dlopen. 
Если необходимо избежать привязки к системным файлам загрузки, то это можно сделать, указав gcc параметр 
"-nostartfiles" в командной строке.

Если одна и та же библиотека загружается дважды через dlopen(), то возвращается один и тот же указатель. 
Библиотека dl поддерживает счетчик ссылок, созданный для указателей на файлы, так что динамическая библиотека 
не может быть выгружена, пока не будет вызвана функция dlclose столько раз, сколько необходимо для успешного 
выполнения функции dlopen .

Если по какой-либо причине выполнение dlopen неудачно, то она возвращает значение NULL.

==============================================================================================================

void *dlsym(void *handle, char *symbol); 
dlsym использует указатель на динамическую библиотеку, возвращаемую dlopen, и оканчивающееся нулем символьное 
имя, а затем возвращает адрес, указывающий, откуда загружается этот символ. Если символ не найден, то 
возвращаемым значением dlsym является NULL; тем не менее, правильным способом проверки dlsym на наличие 
ошибок является сохранение в переменной результата выполнения dlerror, а затем проверка, равно ли это 
значение NULL.

==============================================================================================================

int dlclose(void *handle); 
dlclose уменьшает на единицу счетчик ссылок на указатель динамической библиотеки handle. Если нет других 
загруженных библиотек, использующих ее символы и если счетчик ссылок принимает нулевое значение, то динамическая 
библиотека выгружается. Если динамическая библиотека экпортировала функцию, названную _fini, то эта функция 
вызывается перед выгрузкой библиотеки.   

Возвращает 0 при удачном завершении и ненулевой результат при ошибке.  
==============================================================================================================

gcc -shared -o liballocator.so list.c twins.c -fPIC

    -shared указывает компилятору создать динамическую библиотеку.
    -o liballocator.so указывает имя выходного файла (библиотеки).
    -fPIC используется для создания позиционно-независимого кода, который необходим для динамических библиотек.


gcc -o main main.c -ldl

    -ldl подключает библиотеку динамической загрузки, которая необходима для использования функций dlopen и dlsym.


Теперь вы можете запустить вашу программу. Убедитесь, что библиотека liballocator.so находится в том же каталоге, 
что и исполняемый файл main, или добавьте ее в переменную окружения LD_LIBRARY_PATH:

    export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
    ./main ./liballocator.so
